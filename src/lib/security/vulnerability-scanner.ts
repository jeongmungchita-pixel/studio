import { APIError } from '@/utils/error/api-error';

/**
 * 취약점 타입
 */
export enum VulnerabilityType {
  // 웹 애플리케이션 취약점
  XSS = 'XSS',
  SQL_INJECTION = 'SQL_INJECTION',
  CSRF = 'CSRF',
  CLICKJACKING = 'CLICKJACKING',
  OPEN_REDIRECT = 'OPEN_REDIRECT',
  
  // 인증/권한 취약점
  WEAK_PASSWORD = 'WEAK_PASSWORD',
  INSECURE_SESSION = 'INSECURE_SESSION',
  PRIVILEGE_ESCALATION = 'PRIVILEGE_ESCALATION',
  BROKEN_ACCESS_CONTROL = 'BROKEN_ACCESS_CONTROL',
  
  // 데이터 보안 취약점
  SENSITIVE_DATA_EXPOSURE = 'SENSITIVE_DATA_EXPOSURE',
  INSECURE_STORAGE = 'INSECURE_STORAGE',
  WEAK_ENCRYPTION = 'WEAK_ENCRYPTION',
  
  // 설정 취약점
  SECURITY_MISCONFIGURATION = 'SECURITY_MISCONFIGURATION',
  OUTDATED_COMPONENTS = 'OUTDATED_COMPONENTS',
  INSECURE_HEADERS = 'INSECURE_HEADERS',
  
  // API 취약점
  BROKEN_API_AUTH = 'BROKEN_API_AUTH',
  EXCESSIVE_DATA_EXPOSURE = 'EXCESSIVE_DATA_EXPOSURE',
  RATE_LIMITING_MISSING = 'RATE_LIMITING_MISSING',
}

/**
 * 취약점 심각도
 */
export enum VulnerabilitySeverity {
  INFO = 'INFO',
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH',
  CRITICAL = 'CRITICAL',
}

/**
 * 취약점 정보
 */
export interface Vulnerability {
  id: string;
  type: VulnerabilityType;
  severity: VulnerabilitySeverity;
  title: string;
  description: string;
  location: string;
  evidence?: string;
  recommendation: string;
  cveId?: string;
  cvssScore?: number;
  discoveredAt: Date;
  status: 'open' | 'fixed' | 'accepted' | 'false_positive';
}

/**
 * 스캔 결과
 */
export interface ScanResult {
  id: string;
  startTime: Date;
  endTime: Date;
  duration: number;
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  riskScore: number;
}

/**
 * 취약점 스캐너 클래스
 */
export class VulnerabilityScanner {
  private static scanId = 0;

  /**
   * 전체 보안 스캔 실행
   */
  static async runFullScan(): Promise<ScanResult> {
    const startTime = new Date();
    const scanId = `scan_${++this.scanId}_${Date.now()}`;
    
    console.log(`Starting security scan: ${scanId}`);
    
    const vulnerabilities: Vulnerability[] = [];

    try {
      // 각종 취약점 스캔 실행
      const scanResults = await Promise.allSettled([
        this.scanXSS(),
        this.scanCSRF(),
        this.scanHeaders(),
        this.scanAuthentication(),
        this.scanAuthorization(),
        this.scanDataExposure(),
        this.scanConfiguration(),
        this.scanDependencies(),
      ]);

      // 결과 수집
      scanResults.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          vulnerabilities.push(...result.value);
        } else {
          console.error(`Scan ${index} failed:`, result.reason);
        }
      });

      const endTime = new Date();
      const duration = endTime.getTime() - startTime.getTime();

      // 요약 생성
      const summary = this.generateSummary(vulnerabilities);
      const riskScore = this.calculateRiskScore(vulnerabilities);

      return {
        id: scanId,
        startTime,
        endTime,
        duration,
        vulnerabilities,
        summary,
        riskScore,
      };

    } catch (error) {
      throw new APIError(
        '보안 스캔 중 오류가 발생했습니다',
        'SCAN_ERROR',
        500
      );
    }
  }

  /**
   * XSS 취약점 스캔
   */
  private static async scanXSS(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // DOM 기반 XSS 검사
    if (typeof window !== 'undefined') {
      const dangerousElements = document.querySelectorAll('[onclick], [onload], [onerror]');
      if (dangerousElements.length > 0) {
        vulnerabilities.push({
          id: this.generateVulnId(),
          type: VulnerabilityType.XSS,
          severity: VulnerabilitySeverity.MEDIUM,
          title: 'Inline Event Handlers Detected',
          description: 'HTML 요소에 인라인 이벤트 핸들러가 발견되었습니다.',
          location: 'DOM Elements',
          evidence: `Found ${dangerousElements.length} elements with inline handlers`,
          recommendation: '인라인 이벤트 핸들러를 제거하고 addEventListener를 사용하세요.',
          discoveredAt: new Date(),
          status: 'open',
        });
      }
    }

    // 입력 검증 부족 검사 (시뮬레이션)
    const xssPayloads = [
      '<script>alert("xss")</script>',
      'javascript:alert("xss")',
      '<img src=x onerror=alert("xss")>',
    ];

    // TODO: 실제 입력 필드에 대한 XSS 테스트 구현
    
    return vulnerabilities;
  }

  /**
   * CSRF 취약점 스캔
   */
  private static async scanCSRF(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // CSRF 토큰 검사
    if (typeof document !== 'undefined') {
      const forms = document.querySelectorAll('form');
      const formsWithoutCSRF = Array.from(forms).filter(form => {
        const csrfToken = form.querySelector('input[name*="csrf"], input[name*="token"]');
        return !csrfToken && form.method.toLowerCase() === 'post';
      });

      if (formsWithoutCSRF.length > 0) {
        vulnerabilities.push({
          id: this.generateVulnId(),
          type: VulnerabilityType.CSRF,
          severity: VulnerabilitySeverity.HIGH,
          title: 'Missing CSRF Protection',
          description: 'POST 폼에 CSRF 토큰이 없습니다.',
          location: 'HTML Forms',
          evidence: `${formsWithoutCSRF.length} forms without CSRF tokens`,
          recommendation: '모든 POST 폼에 CSRF 토큰을 추가하세요.',
          discoveredAt: new Date(),
          status: 'open',
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * 보안 헤더 스캔
   */
  private static async scanHeaders(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // 필수 보안 헤더 검사
    const requiredHeaders = [
      'X-Frame-Options',
      'X-Content-Type-Options',
      'X-XSS-Protection',
      'Strict-Transport-Security',
      'Content-Security-Policy',
    ];

    // TODO: 실제 HTTP 응답 헤더 검사 구현
    // 현재는 시뮬레이션
    const missingHeaders = requiredHeaders.filter(header => {
      // 실제 구현에서는 응답 헤더를 확인
      return Math.random() > 0.7; // 30% 확률로 누락된 것으로 시뮬레이션
    });

    if (missingHeaders.length > 0) {
      vulnerabilities.push({
        id: this.generateVulnId(),
        type: VulnerabilityType.INSECURE_HEADERS,
        severity: VulnerabilitySeverity.MEDIUM,
        title: 'Missing Security Headers',
        description: '필수 보안 헤더가 누락되었습니다.',
        location: 'HTTP Response Headers',
        evidence: `Missing headers: ${missingHeaders.join(', ')}`,
        recommendation: '누락된 보안 헤더를 추가하세요.',
        discoveredAt: new Date(),
        status: 'open',
      });
    }

    return vulnerabilities;
  }

  /**
   * 인증 취약점 스캔
   */
  private static async scanAuthentication(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // 약한 비밀번호 정책 검사
    const passwordPolicy = {
      minLength: 8,
      requireUppercase: true,
      requireLowercase: true,
      requireNumbers: true,
      requireSpecialChars: true,
    };

    // TODO: 실제 비밀번호 정책 검사 구현
    if (!passwordPolicy.requireSpecialChars) {
      vulnerabilities.push({
        id: this.generateVulnId(),
        type: VulnerabilityType.WEAK_PASSWORD,
        severity: VulnerabilitySeverity.MEDIUM,
        title: 'Weak Password Policy',
        description: '비밀번호 정책이 충분히 강력하지 않습니다.',
        location: 'Authentication System',
        evidence: 'Special characters not required',
        recommendation: '더 강력한 비밀번호 정책을 적용하세요.',
        discoveredAt: new Date(),
        status: 'open',
      });
    }

    // 세션 보안 검사
    if (typeof document !== 'undefined') {
      const cookies = document.cookie;
      if (cookies && !cookies.includes('Secure') && !cookies.includes('HttpOnly')) {
        vulnerabilities.push({
          id: this.generateVulnId(),
          type: VulnerabilityType.INSECURE_SESSION,
          severity: VulnerabilitySeverity.HIGH,
          title: 'Insecure Session Cookies',
          description: '세션 쿠키에 보안 플래그가 설정되지 않았습니다.',
          location: 'Session Management',
          evidence: 'Missing Secure and HttpOnly flags',
          recommendation: '세션 쿠키에 Secure, HttpOnly 플래그를 설정하세요.',
          discoveredAt: new Date(),
          status: 'open',
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * 권한 취약점 스캔
   */
  private static async scanAuthorization(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // TODO: 실제 권한 검사 로직 구현
    // 현재는 시뮬레이션

    // 권한 상승 가능성 검사
    const hasPrivilegeEscalation = Math.random() > 0.9; // 10% 확률
    if (hasPrivilegeEscalation) {
      vulnerabilities.push({
        id: this.generateVulnId(),
        type: VulnerabilityType.PRIVILEGE_ESCALATION,
        severity: VulnerabilitySeverity.CRITICAL,
        title: 'Privilege Escalation Vulnerability',
        description: '권한 상승 취약점이 발견되었습니다.',
        location: 'Authorization System',
        evidence: 'User can access higher privilege functions',
        recommendation: '권한 검사 로직을 강화하세요.',
        discoveredAt: new Date(),
        status: 'open',
      });
    }

    return vulnerabilities;
  }

  /**
   * 데이터 노출 스캔
   */
  private static async scanDataExposure(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // 민감한 데이터 노출 검사
    if (typeof window !== 'undefined') {
      const scripts = document.querySelectorAll('script');
      let hasExposedData = false;

      scripts.forEach(script => {
        const content = script.textContent || '';
        if (content.includes('password') || content.includes('token') || content.includes('key')) {
          hasExposedData = true;
        }
      });

      if (hasExposedData) {
        vulnerabilities.push({
          id: this.generateVulnId(),
          type: VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
          severity: VulnerabilitySeverity.HIGH,
          title: 'Sensitive Data in Client-Side Code',
          description: '클라이언트 코드에 민감한 데이터가 노출되었습니다.',
          location: 'JavaScript Code',
          evidence: 'Sensitive keywords found in scripts',
          recommendation: '민감한 데이터를 클라이언트 코드에서 제거하세요.',
          discoveredAt: new Date(),
          status: 'open',
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * 설정 취약점 스캔
   */
  private static async scanConfiguration(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // 개발 모드 확인
    if (process.env.NODE_ENV === 'development') {
      vulnerabilities.push({
        id: this.generateVulnId(),
        type: VulnerabilityType.SECURITY_MISCONFIGURATION,
        severity: VulnerabilitySeverity.INFO,
        title: 'Development Mode Detected',
        description: '개발 모드로 실행 중입니다.',
        location: 'Application Configuration',
        evidence: 'NODE_ENV=development',
        recommendation: '프로덕션에서는 NODE_ENV=production으로 설정하세요.',
        discoveredAt: new Date(),
        status: 'open',
      });
    }

    // 디버그 정보 노출 검사
    if (typeof console !== 'undefined' && console.log.toString().includes('native')) {
      // 콘솔이 활성화된 경우
      vulnerabilities.push({
        id: this.generateVulnId(),
        type: VulnerabilityType.SECURITY_MISCONFIGURATION,
        severity: VulnerabilitySeverity.LOW,
        title: 'Debug Information Exposure',
        description: '디버그 정보가 노출될 수 있습니다.',
        location: 'Console Output',
        evidence: 'Console logging enabled',
        recommendation: '프로덕션에서는 콘솔 로깅을 비활성화하세요.',
        discoveredAt: new Date(),
        status: 'open',
      });
    }

    return vulnerabilities;
  }

  /**
   * 의존성 취약점 스캔
   */
  private static async scanDependencies(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // TODO: 실제 package.json 분석 및 취약점 데이터베이스 조회
    // 현재는 시뮬레이션

    const hasOutdatedDeps = Math.random() > 0.8; // 20% 확률
    if (hasOutdatedDeps) {
      vulnerabilities.push({
        id: this.generateVulnId(),
        type: VulnerabilityType.OUTDATED_COMPONENTS,
        severity: VulnerabilitySeverity.MEDIUM,
        title: 'Outdated Dependencies',
        description: '오래된 의존성 패키지가 발견되었습니다.',
        location: 'Package Dependencies',
        evidence: 'Some packages have known vulnerabilities',
        recommendation: '의존성 패키지를 최신 버전으로 업데이트하세요.',
        discoveredAt: new Date(),
        status: 'open',
      });
    }

    return vulnerabilities;
  }

  /**
   * 요약 생성
   */
  private static generateSummary(vulnerabilities: Vulnerability[]) {
    const summary = {
      total: vulnerabilities.length,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0,
    };

    vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case VulnerabilitySeverity.CRITICAL:
          summary.critical++;
          break;
        case VulnerabilitySeverity.HIGH:
          summary.high++;
          break;
        case VulnerabilitySeverity.MEDIUM:
          summary.medium++;
          break;
        case VulnerabilitySeverity.LOW:
          summary.low++;
          break;
        case VulnerabilitySeverity.INFO:
          summary.info++;
          break;
      }
    });

    return summary;
  }

  /**
   * 위험 점수 계산
   */
  private static calculateRiskScore(vulnerabilities: Vulnerability[]): number {
    const weights = {
      [VulnerabilitySeverity.CRITICAL]: 10,
      [VulnerabilitySeverity.HIGH]: 7,
      [VulnerabilitySeverity.MEDIUM]: 4,
      [VulnerabilitySeverity.LOW]: 2,
      [VulnerabilitySeverity.INFO]: 1,
    };

    const totalScore = vulnerabilities.reduce((score, vuln) => {
      return score + weights[vuln.severity];
    }, 0);

    // 0-100 스케일로 정규화
    return Math.min(Math.round(totalScore * 2), 100);
  }

  /**
   * 취약점 ID 생성
   */
  private static generateVulnId(): string {
    return `vuln_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
  }

  /**
   * 스캔 보고서 생성
   */
  static generateReport(scanResult: ScanResult, format: 'json' | 'html' | 'csv' = 'json'): string {
    switch (format) {
      case 'html':
        return this.generateHTMLReport(scanResult);
      case 'csv':
        return this.generateCSVReport(scanResult);
      default:
        return JSON.stringify(scanResult, null, 2);
    }
  }

  /**
   * HTML 보고서 생성
   */
  private static generateHTMLReport(scanResult: ScanResult): string {
    const { summary, riskScore, vulnerabilities } = scanResult;
    
    return `
<!DOCTYPE html>
<html>
<head>
    <title>Security Scan Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f5f5f5; padding: 20px; border-radius: 5px; }
        .summary { display: flex; gap: 20px; margin: 20px 0; }
        .metric { background: #fff; border: 1px solid #ddd; padding: 15px; border-radius: 5px; }
        .critical { color: #d32f2f; }
        .high { color: #f57c00; }
        .medium { color: #fbc02d; }
        .low { color: #388e3c; }
        .vulnerability { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Security Scan Report</h1>
        <p>Scan ID: ${scanResult.id}</p>
        <p>Duration: ${scanResult.duration}ms</p>
        <p>Risk Score: ${riskScore}/100</p>
    </div>
    
    <div class="summary">
        <div class="metric critical">Critical: ${summary.critical}</div>
        <div class="metric high">High: ${summary.high}</div>
        <div class="metric medium">Medium: ${summary.medium}</div>
        <div class="metric low">Low: ${summary.low}</div>
        <div class="metric">Info: ${summary.info}</div>
    </div>
    
    <h2>Vulnerabilities</h2>
    ${vulnerabilities.map(vuln => `
        <div class="vulnerability">
            <h3 class="${vuln.severity.toLowerCase()}">${vuln.title}</h3>
            <p><strong>Severity:</strong> ${vuln.severity}</p>
            <p><strong>Type:</strong> ${vuln.type}</p>
            <p><strong>Location:</strong> ${vuln.location}</p>
            <p><strong>Description:</strong> ${vuln.description}</p>
            <p><strong>Recommendation:</strong> ${vuln.recommendation}</p>
            ${vuln.evidence ? `<p><strong>Evidence:</strong> ${vuln.evidence}</p>` : ''}
        </div>
    `).join('')}
</body>
</html>`;
  }

  /**
   * CSV 보고서 생성
   */
  private static generateCSVReport(scanResult: ScanResult): string {
    const headers = [
      'ID', 'Type', 'Severity', 'Title', 'Description', 'Location', 
      'Evidence', 'Recommendation', 'Status', 'Discovered At'
    ];
    
    const rows = scanResult.vulnerabilities.map(vuln => [
      vuln.id,
      vuln.type,
      vuln.severity,
      vuln.title,
      vuln.description,
      vuln.location,
      vuln.evidence || '',
      vuln.recommendation,
      vuln.status,
      vuln.discoveredAt.toISOString()
    ]);
    
    return [headers, ...rows].map(row => row.join(',')).join('\n');
  }
}
