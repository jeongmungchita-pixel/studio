import { APIError } from '@/lib/error/error-manager';
/**
 * 취약점 타입
 */
export enum VulnerabilityType {
  // 웹 애플리케이션 취약점
  XSS = 'XSS',
  SQL_INJECTION = 'SQL_INJECTION',
  CSRF = 'CSRF',
  CLICKJACKING = 'CLICKJACKING',
  OPEN_REDIRECT = 'OPEN_REDIRECT',
  // 인증/권한 취약점
  WEAK_PASSWORD = 'WEAK_PASSWORD',
  INSECURE_SESSION = 'INSECURE_SESSION',
  PRIVILEGE_ESCALATION = 'PRIVILEGE_ESCALATION',
  BROKEN_ACCESS_CONTROL = 'BROKEN_ACCESS_CONTROL',
  // 데이터 보안 취약점
  SENSITIVE_DATA_EXPOSURE = 'SENSITIVE_DATA_EXPOSURE',
  INSECURE_STORAGE = 'INSECURE_STORAGE',
  WEAK_ENCRYPTION = 'WEAK_ENCRYPTION',
  // 설정 취약점
  SECURITY_MISCONFIGURATION = 'SECURITY_MISCONFIGURATION',
  OUTDATED_COMPONENTS = 'OUTDATED_COMPONENTS',
  INSECURE_HEADERS = 'INSECURE_HEADERS',
  // API 취약점
  BROKEN_API_AUTH = 'BROKEN_API_AUTH',
  EXCESSIVE_DATA_EXPOSURE = 'EXCESSIVE_DATA_EXPOSURE',
  RATE_LIMITING_MISSING = 'RATE_LIMITING_MISSING',
}
/**
 * 취약점 심각도
 */
export enum VulnerabilitySeverity {
  INFO = 'INFO',
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH',
  CRITICAL = 'CRITICAL',
}
/**
 * 취약점 정보
 */
export interface Vulnerability {
  id: string;
  type: VulnerabilityType;
  severity: VulnerabilitySeverity;
  title: string;
  description: string;
  location: string;
  evidence?: string;
  recommendation: string;
  cveId?: string;
  cvssScore?: number;
  discoveredAt: Date;
  status: 'open' | 'fixed' | 'accepted' | 'false_positive';
}
/**
 * 스캔 결과
 */
export interface ScanResult {
  id: string;
  startTime: Date;
  endTime: Date;
  duration: number;
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  riskScore: number;
}
/**
 * 취약점 스캐너 클래스
 */
export class VulnerabilityScanner {
  private static scanId = 0;
  /**
   * 전체 보안 스캔 실행
   */
  static async runFullScan(): Promise<ScanResult> {
    const startTime = new Date();
    const scanId = `scan_${++this.scanId}_${Date.now()}`;
    const vulnerabilities: Vulnerability[] = [];
    try {
      // 각종 취약점 스캔 실행
      const scanResults = await Promise.allSettled([
        this.scanXSS(),
        this.scanCSRF(),
        this.scanHeaders(),
        this.scanAuthentication(),
        this.scanAuthorization(),
        this.scanDataExposure(),
        this.scanConfiguration(),
        this.scanDependencies(),
      ]);
      // 결과 수집
      scanResults.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          vulnerabilities.push(...result.value);
        } else {
        }
      });
      const endTime = new Date();
      const duration = endTime.getTime() - startTime.getTime();
      // 요약 생성
      const summary = this.generateSummary(vulnerabilities);
      const riskScore = this.calculateRiskScore(vulnerabilities);
      return {
        id: scanId,
        startTime,
        endTime,
        duration,
        vulnerabilities,
        summary,
        riskScore,
      };
    } catch (error: unknown) {
      throw new APIError(
        '보안 스캔 중 오류가 발생했습니다', 500, 'SCAN_ERROR'
      );
    }
  }
  /**
   * XSS 취약점 스캔
   */
  private static async scanXSS(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    // DOM 기반 XSS 검사
    if (typeof window !== 'undefined') {
      const dangerousElements = document.querySelectorAll('[onclick], [onload], [onerror]');
      if (dangerousElements.length > 0) {
        vulnerabilities.push({
          id: this.generateVulnId(),
          type: VulnerabilityType.XSS,
          severity: VulnerabilitySeverity.MEDIUM,
          title: 'Inline Event Handlers Detected',
          description: 'HTML 요소에 인라인 이벤트 핸들러가 발견되었습니다.',
          location: 'DOM Elements',
          evidence: `Found ${dangerousElements.length} elements with inline handlers`,
          recommendation: '인라인 이벤트 핸들러를 제거하고 addEventListener를 사용하세요.',
          discoveredAt: new Date(),
          status: 'open',
        });
      }
    }
    // 입력 검증 부족 검사 (시뮬레이션)
    const xssPayloads = [
      '<script>alert("xss")</script>',
      'javascript:alert("xss")',
      '<img src=x onerror=alert("xss")>',
    ];
    // TODO: 실제 입력 필드에 대한 XSS 테스트 구현
    return vulnerabilities;
  }
  /**
   * CSRF 취약점 스캔
   */
  private static async scanCSRF(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    // CSRF 토큰 검사
    if (typeof document !== 'undefined') {
      const forms = document.querySelectorAll('form');
      const formsWithoutCSRF = Array.from(forms).filter(form => {
        const csrfToken = form.querySelector('input[name*="csrf"], input[name*="token"]');
        return !csrfToken && form.method.toLowerCase() === 'post';
      });
      if (formsWithoutCSRF.length > 0) {
        vulnerabilities.push({
          id: this.generateVulnId(),
          type: VulnerabilityType.CSRF,
          severity: VulnerabilitySeverity.HIGH,
          title: 'Missing CSRF Protection',
          description: 'POST 폼에 CSRF 토큰이 없습니다.',
          location: 'HTML Forms',
          evidence: `${formsWithoutCSRF.length} forms without CSRF tokens`,
          recommendation: '모든 POST 폼에 CSRF 토큰을 추가하세요.',
          discoveredAt: new Date(),
          status: 'open',
        });
      }
    }
    return vulnerabilities;
  }
  /**
   * 보안 헤더 스캔
   */
  private static async scanHeaders(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    // 필수 보안 헤더 검사
    const requiredHeaders = [
      'X-Frame-Options',
      'X-Content-Type-Options',
      'X-XSS-Protection',
      'Strict-Transport-Security',
      'Content-Security-Policy',
    ];
    // 실제 HTTP 응답 헤더 검사
    const missingHeaders: string[] = [];
    
    // 브라우저 환경에서 현재 페이지의 헤더 확인
    if (typeof window !== 'undefined' && 'performance' in window) {
      const entries = performance.getEntriesByType('navigation') as PerformanceNavigationTiming[];
      if (entries.length > 0 && entries[0].serverTiming) {
        // 서버에서 보낸 헤더 정보 확인 (제한적)
        requiredHeaders.forEach(header => {
          // meta 태그로 일부 보안 정책 확인
          if (header === 'Content-Security-Policy') {
            const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
            if (!cspMeta) {
              missingHeaders.push(header);
            }
          } else if (header === 'X-Frame-Options') {
            // iframe 테스트로 X-Frame-Options 추정
            try {
              const testIframe = document.createElement('iframe');
              testIframe.src = window.location.href;
              testIframe.style.display = 'none';
              document.body.appendChild(testIframe);
              // 즉시 제거
              document.body.removeChild(testIframe);
              // 에러가 없으면 X-Frame-Options이 설정되지 않았을 가능성
              missingHeaders.push(header);
            } catch {
              // 에러가 발생하면 X-Frame-Options이 설정됨
            }
          }
        });
      }
    }
    if (missingHeaders.length > 0) {
      vulnerabilities.push({
        id: this.generateVulnId(),
        type: VulnerabilityType.INSECURE_HEADERS,
        severity: VulnerabilitySeverity.MEDIUM,
        title: 'Missing Security Headers',
        description: '필수 보안 헤더가 누락되었습니다.',
        location: 'HTTP Response Headers',
        evidence: `Missing headers: ${missingHeaders.join(', ')}`,
        recommendation: '누락된 보안 헤더를 추가하세요.',
        discoveredAt: new Date(),
        status: 'open',
      });
    }
    return vulnerabilities;
  }
  /**
   * 인증 취약점 스캔
   */
  private static async scanAuthentication(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    // 약한 비밀번호 정책 검사
    const passwordPolicy = {
      minLength: 8,
      requireUppercase: true,
      requireLowercase: true,
      requireNumbers: true,
      requireSpecialChars: true,
    };
    // 실제 비밀번호 정책 검사
    const checkPasswordPolicy = () => {
      const issues: string[] = [];
      
      // 비밀번호 입력 필드 찾기
      if (typeof document !== 'undefined') {
        const passwordInputs = document.querySelectorAll('input[type="password"]');
        
        passwordInputs.forEach(input => {
          // minlength 속성 확인
          const minLength = input.getAttribute('minlength');
          if (!minLength || parseInt(minLength) < 8) {
            issues.push('최소 길이 8자 미만');
          }
          
          // pattern 속성 확인 (정규식으로 복잡도 확인)
          const pattern = input.getAttribute('pattern');
          if (!pattern) {
            issues.push('패턴 검증 없음');
          } else {
            if (!pattern.includes('[A-Z]')) issues.push('대문자 필수 아님');
            if (!pattern.includes('[a-z]')) issues.push('소문자 필수 아님');
            if (!pattern.includes('[0-9]')) issues.push('숫자 필수 아님');
            if (!pattern.includes('[!@#$%^&*]')) issues.push('특수문자 필수 아님');
          }
          
          // maxlength 확인 (너무 긴 비밀번호 제한)
          const maxLength = input.getAttribute('maxlength');
          if (!maxLength || parseInt(maxLength) > 128) {
            issues.push('최대 길이 제한 없음');
          }
        });
        
        // 비밀번호 정책이 약한 경우
        if (issues.length > 0) {
          vulnerabilities.push({
            id: this.generateVulnId(),
            type: VulnerabilityType.WEAK_PASSWORD,
            severity: issues.length > 3 ? VulnerabilitySeverity.HIGH : VulnerabilitySeverity.MEDIUM,
            title: 'Weak Password Policy',
            description: '비밀번호 정책이 충분히 강력하지 않습니다.',
            location: 'Authentication System',
            evidence: `Issues found: ${issues.join(', ')}`,
            recommendation: '최소 8자, 대소문자, 숫자, 특수문자를 포함하는 비밀번호 정책을 적용하세요.',
            discoveredAt: new Date(),
            status: 'open',
          });
        }
      }
    };
    
    checkPasswordPolicy();
    // 세션 보안 검사
    if (typeof document !== 'undefined') {
      const cookies = document.cookie;
      if (cookies && !cookies.includes('Secure') && !cookies.includes('HttpOnly')) {
        vulnerabilities.push({
          id: this.generateVulnId(),
          type: VulnerabilityType.INSECURE_SESSION,
          severity: VulnerabilitySeverity.HIGH,
          title: 'Insecure Session Cookies',
          description: '세션 쿠키에 보안 플래그가 설정되지 않았습니다.',
          location: 'Session Management',
          evidence: 'Missing Secure and HttpOnly flags',
          recommendation: '세션 쿠키에 Secure, HttpOnly 플래그를 설정하세요.',
          discoveredAt: new Date(),
          status: 'open',
        });
      }
    }
    return vulnerabilities;
  }
  /**
   * 권한 취약점 스캔
   */
  private static async scanAuthorization(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // 실제 권한 검사 로직
    if (typeof window !== 'undefined') {
      const issues: string[] = [];
      
      // localStorage/sessionStorage에 민감한 정보 저장 확인
      const checkStorage = (storage: Storage, name: string) => {
        const keys = Object.keys(storage);
        const sensitivePatterns = [
          /token/i,
          /password/i,
          /secret/i,
          /api[_-]?key/i,
          /private/i,
          /credential/i,
          /auth/i,
          /session/i
        ];
        
        keys.forEach(key => {
          const value = storage.getItem(key);
          if (value) {
            // 민감한 키 이름 확인
            if (sensitivePatterns.some(pattern => pattern.test(key))) {
              // JWT 토큰인지 확인
              if (value.split('.').length === 3) {
                try {
                  // JWT payload 디코딩 (base64)
                  const payload = JSON.parse(atob(value.split('.')[1]));
                  if (payload.role || payload.permissions || payload.admin) {
                    issues.push(`${name}에 권한 정보가 포함된 JWT 토큰 발견: ${key}`);
                  }
                } catch {}
              } else if (value.includes('admin') || value.includes('SUPER_ADMIN')) {
                issues.push(`${name}에 관리자 권한 정보 노출: ${key}`);
              }
            }
            
            // Base64로 인코딩된 민감한 데이터 확인
            try {
              const decoded = atob(value);
              if (decoded.includes('admin') || decoded.includes('root')) {
                issues.push(`${name}에 Base64 인코딩된 권한 정보: ${key}`);
              }
            } catch {}
          }
        });
      };
      
      // localStorage 검사
      checkStorage(localStorage, 'localStorage');
      // sessionStorage 검사
      checkStorage(sessionStorage, 'sessionStorage');
      
      // 쿠키에서 권한 정보 확인
      if (document.cookie) {
        const cookies = document.cookie.split(';');
        cookies.forEach(cookie => {
          const [name, value] = cookie.trim().split('=');
          if (name && value) {
            if (name.toLowerCase().includes('admin') || 
                name.toLowerCase().includes('role') ||
                value.includes('SUPER_ADMIN') ||
                value.includes('admin":true')) {
              issues.push(`쿠키에 권한 정보 노출: ${name}`);
            }
          }
        });
      }
      
      // DOM에서 숨겨진 권한 정보 확인
      const hiddenInputs = document.querySelectorAll('input[type="hidden"]');
      hiddenInputs.forEach(input => {
        const name = input.getAttribute('name') || '';
        const value = input.getAttribute('value') || '';
        if ((name.toLowerCase().includes('role') || 
             name.toLowerCase().includes('permission') ||
             name.toLowerCase().includes('admin')) &&
            (value.includes('admin') || value.includes('SUPER'))) {
          issues.push(`DOM에 숨겨진 권한 정보: ${name}=${value}`);
        }
      });
      
      // 권한 관련 취약점이 발견된 경우
      if (issues.length > 0) {
        vulnerabilities.push({
          id: this.generateVulnId(),
          type: VulnerabilityType.BROKEN_ACCESS_CONTROL,
          severity: issues.length > 2 ? VulnerabilitySeverity.CRITICAL : VulnerabilitySeverity.HIGH,
          title: 'Access Control Issues Detected',
          description: '클라이언트 사이드에 권한 정보가 노출되어 있습니다.',
          location: 'Client-Side Storage',
          evidence: issues.slice(0, 3).join('; '),
          recommendation: '권한 정보는 서버 사이드에서만 관리하고, 클라이언트에는 최소한의 정보만 저장하세요.',
          discoveredAt: new Date(),
          status: 'open',
        });
      }
      
      // URL에서 권한 파라미터 확인
      const urlParams = new URLSearchParams(window.location.search);
      const dangerousParams = ['admin', 'role', 'permission', 'debug', 'test'];
      dangerousParams.forEach(param => {
        if (urlParams.has(param)) {
          vulnerabilities.push({
            id: this.generateVulnId(),
            type: VulnerabilityType.BROKEN_ACCESS_CONTROL,
            severity: VulnerabilitySeverity.MEDIUM,
            title: 'Sensitive Parameters in URL',
            description: 'URL에 권한 관련 파라미터가 노출되어 있습니다.',
            location: 'URL Parameters',
            evidence: `Found parameter: ${param}=${urlParams.get(param)}`,
            recommendation: 'URL 파라미터로 권한을 제어하지 마세요. 서버 사이드 세션을 사용하세요.',
            discoveredAt: new Date(),
            status: 'open',
          });
        }
      });
    }
    
    return vulnerabilities;
  }
  /**
   * 데이터 노출 스캔
   */
  private static async scanDataExposure(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    // 민감한 데이터 노출 검사
    if (typeof window !== 'undefined') {
      const scripts = document.querySelectorAll('script');
      let hasExposedData = false;
      scripts.forEach(script => {
        const content = script.textContent || '';
        if (content.includes('password') || content.includes('token') || content.includes('key')) {
          hasExposedData = true;
        }
      });
      if (hasExposedData) {
        vulnerabilities.push({
          id: this.generateVulnId(),
          type: VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
          severity: VulnerabilitySeverity.HIGH,
          title: 'Sensitive Data in Client-Side Code',
          description: '클라이언트 코드에 민감한 데이터가 노출되었습니다.',
          location: 'JavaScript Code',
          evidence: 'Sensitive keywords found in scripts',
          recommendation: '민감한 데이터를 클라이언트 코드에서 제거하세요.',
          discoveredAt: new Date(),
          status: 'open',
        });
      }
    }
    return vulnerabilities;
  }
  /**
   * 설정 취약점 스캔
   */
  private static async scanConfiguration(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    // 개발 모드 확인
    if (process.env.NODE_ENV === 'development') {
      vulnerabilities.push({
        id: this.generateVulnId(),
        type: VulnerabilityType.SECURITY_MISCONFIGURATION,
        severity: VulnerabilitySeverity.INFO,
        title: 'Development Mode Detected',
        description: '개발 모드로 실행 중입니다.',
        location: 'Application Configuration',
        evidence: 'NODE_ENV=development',
        recommendation: '프로덕션에서는 NODE_ENV=production으로 설정하세요.',
        discoveredAt: new Date(),
        status: 'open',
      });
    }
    // 디버그 정보 노출 검사
    if (typeof console !== 'undefined' && console.log.toString().includes('native')) {
      // 콘솔이 활성화된 경우
      vulnerabilities.push({
        id: this.generateVulnId(),
        type: VulnerabilityType.SECURITY_MISCONFIGURATION,
        severity: VulnerabilitySeverity.LOW,
        title: 'Debug Information Exposure',
        description: '디버그 정보가 노출될 수 있습니다.',
        location: 'Console Output',
        evidence: 'Console logging enabled',
        recommendation: '프로덕션에서는 콘솔 로깅을 비활성화하세요.',
        discoveredAt: new Date(),
        status: 'open',
      });
    }
    return vulnerabilities;
  }
  /**
   * 의존성 취약점 스캔
   */
  private static async scanDependencies(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // 알려진 취약한 패키지 버전 (예시)
    const knownVulnerabilities: Record<string, { minSafeVersion: string; vulnerability: string }> = {
      'react': { minSafeVersion: '18.2.0', vulnerability: 'XSS vulnerability in older versions' },
      'next': { minSafeVersion: '13.0.0', vulnerability: 'Security patches in v13+' },
      'axios': { minSafeVersion: '1.6.0', vulnerability: 'SSRF vulnerability in < 1.6.0' },
      'lodash': { minSafeVersion: '4.17.21', vulnerability: 'Prototype pollution' },
      'minimist': { minSafeVersion: '1.2.6', vulnerability: 'Prototype pollution' },
      'node-fetch': { minSafeVersion: '3.3.0', vulnerability: 'DNS rebinding vulnerability' },
      'express': { minSafeVersion: '4.18.0', vulnerability: 'RegEx DoS vulnerability' },
      'jsonwebtoken': { minSafeVersion: '9.0.0', vulnerability: 'Security improvements in v9' },
    };
    
    // 클라이언트 사이드에서 의존성 정보 확인 (제한적)
    if (typeof window !== 'undefined') {
      // React 버전 확인
      try {
        const React = (window as any).React;
        if (React && React.version) {
          const reactVersion = React.version;
          if (this.compareVersions(reactVersion, knownVulnerabilities['react'].minSafeVersion) < 0) {
            vulnerabilities.push({
              id: this.generateVulnId(),
              type: VulnerabilityType.OUTDATED_COMPONENTS,
              severity: VulnerabilitySeverity.HIGH,
              title: 'Outdated React Version',
              description: `React ${reactVersion}에 알려진 취약점이 있습니다.`,
              location: 'Frontend Dependencies',
              evidence: `Current: ${reactVersion}, Required: ${knownVulnerabilities['react'].minSafeVersion}`,
              recommendation: `React를 ${knownVulnerabilities['react'].minSafeVersion} 이상으로 업데이트하세요.`,
              cveId: 'CVE-2022-24785',
              discoveredAt: new Date(),
              status: 'open',
            });
          }
        }
      } catch {}
      
      // Next.js 버전 확인
      try {
        const nextData = document.getElementById('__NEXT_DATA__');
        if (nextData) {
          const data = JSON.parse(nextData.textContent || '{}');
          if (data.buildId) {
            // 빌드 ID로 대략적인 버전 추정 (정확하지 않음)
            vulnerabilities.push({
              id: this.generateVulnId(),
              type: VulnerabilityType.OUTDATED_COMPONENTS,
              severity: VulnerabilitySeverity.INFO,
              title: 'Dependency Version Check Needed',
              description: '의존성 패키지 버전을 수동으로 확인해야 합니다.',
              location: 'package.json',
              evidence: 'Automated version detection limited in browser',
              recommendation: 'npm audit 또는 yarn audit을 실행하여 취약점을 확인하세요.',
              discoveredAt: new Date(),
              status: 'open',
            });
          }
        }
      } catch {}
    }
    
    return vulnerabilities;
  }
  
  /**
   * 버전 비교 헬퍼 함수
   */
  private static compareVersions(version1: string, version2: string): number {
    const v1Parts = version1.split('.').map(Number);
    const v2Parts = version2.split('.').map(Number);
    
    for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
      const v1Part = v1Parts[i] || 0;
      const v2Part = v2Parts[i] || 0;
      
      if (v1Part < v2Part) return -1;
      if (v1Part > v2Part) return 1;
    }
    
    return 0;
  }
  /**
   * 요약 생성
   */
  private static generateSummary(vulnerabilities: Vulnerability[]) {
    const summary = {
      total: vulnerabilities.length,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0,
    };
    vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case VulnerabilitySeverity.CRITICAL:
          summary.critical++;
          break;
        case VulnerabilitySeverity.HIGH:
          summary.high++;
          break;
        case VulnerabilitySeverity.MEDIUM:
          summary.medium++;
          break;
        case VulnerabilitySeverity.LOW:
          summary.low++;
          break;
        case VulnerabilitySeverity.INFO:
          summary.info++;
          break;
      }
    });
    return summary;
  }
  /**
   * 위험 점수 계산
   */
  private static calculateRiskScore(vulnerabilities: Vulnerability[]): number {
    const weights = {
      [VulnerabilitySeverity.CRITICAL]: 10,
      [VulnerabilitySeverity.HIGH]: 7,
      [VulnerabilitySeverity.MEDIUM]: 4,
      [VulnerabilitySeverity.LOW]: 2,
      [VulnerabilitySeverity.INFO]: 1,
    };
    const totalScore = vulnerabilities.reduce((score, vuln) => {
      return score + weights[vuln.severity];
    }, 0);
    // 0-100 스케일로 정규화
    return Math.min(Math.round(totalScore * 2), 100);
  }
  /**
   * 취약점 ID 생성
   */
  private static generateVulnId(): string {
    return `vuln_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
  }
  /**
   * 스캔 보고서 생성
   */
  static generateReport(scanResult: ScanResult, format: 'json' | 'html' | 'csv' = 'json'): string {
    switch (format) {
      case 'html':
        return this.generateHTMLReport(scanResult);
      case 'csv':
        return this.generateCSVReport(scanResult);
      default:
        return JSON.stringify(scanResult, null, 2);
    }
  }
  /**
   * HTML 보고서 생성
   */
  private static generateHTMLReport(scanResult: ScanResult): string {
    const { summary, riskScore, vulnerabilities } = scanResult;
    return `
<!DOCTYPE html>
<html>
<head>
    <title>Security Scan Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f5f5f5; padding: 20px; border-radius: 5px; }
        .summary { display: flex; gap: 20px; margin: 20px 0; }
        .metric { background: #fff; border: 1px solid #ddd; padding: 15px; border-radius: 5px; }
        .critical { color: #d32f2f; }
        .high { color: #f57c00; }
        .medium { color: #fbc02d; }
        .low { color: #388e3c; }
        .vulnerability { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Security Scan Report</h1>
        <p>Scan ID: ${scanResult.id}</p>
        <p>Duration: ${scanResult.duration}ms</p>
        <p>Risk Score: ${riskScore}/100</p>
    </div>
    <div class="summary">
        <div class="metric critical">Critical: ${summary.critical}</div>
        <div class="metric high">High: ${summary.high}</div>
        <div class="metric medium">Medium: ${summary.medium}</div>
        <div class="metric low">Low: ${summary.low}</div>
        <div class="metric">Info: ${summary.info}</div>
    </div>
    <h2>Vulnerabilities</h2>
    ${vulnerabilities.map(vuln => `
        <div class="vulnerability">
            <h3 class="${vuln.severity.toLowerCase()}">${vuln.title}</h3>
            <p><strong>Severity:</strong> ${vuln.severity}</p>
            <p><strong>Type:</strong> ${vuln.type}</p>
            <p><strong>Location:</strong> ${vuln.location}</p>
            <p><strong>Description:</strong> ${vuln.description}</p>
            <p><strong>Recommendation:</strong> ${vuln.recommendation}</p>
            ${vuln.evidence ? `<p><strong>Evidence:</strong> ${vuln.evidence}</p>` : ''}
        </div>
    `).join('')}
</body>
</html>`;
  }
  /**
   * CSV 보고서 생성
   */
  private static generateCSVReport(scanResult: ScanResult): string {
    const headers = [
      'ID', 'Type', 'Severity', 'Title', 'Description', 'Location', 
      'Evidence', 'Recommendation', 'Status', 'Discovered At'
    ];
    const rows = scanResult.vulnerabilities.map(vuln => [
      vuln.id,
      vuln.type,
      vuln.severity,
      vuln.title,
      vuln.description,
      vuln.location,
      vuln.evidence || '',
      vuln.recommendation,
      vuln.status,
      vuln.discoveredAt.toISOString()
    ]);
    return [headers, ...rows].map(row => row.join(',')).join('\n');
  }
}
